// *CCITT CRC-16 is calculated from the chunk data and the 16-bit (2-byte) chunk index
// https://srecord.sourceforge.net/crc16-ccitt.html
pub const CCITT: crc::Crc<u16> = crc::Crc::<u16>::new(&crc::CRC_16_IBM_3740);

// offset of chunks in system page
// oSysChunks = 260 (header + chunks length)

fn crc_table() -> [u16; 256] {
    let mut table = [0u16; 256];
    for (i, e) in table.iter_mut().enumerate() {
        let mut r = i << 8;
        for _ in 0..8 {
            let poly = if r & 0x8000 != 0 { 0x1021 } else { 0 };
            r = (r << 1) ^ poly;
        }
        *e = r as u16;
    }
    table
}

fn crc_idx(v: u16) -> u16 {
    let tab = crc_table();

    let v = [v as u8, (v >> 8) as u8];

    let mut crc: u16 = 0x3fff;
    for b in v {
        let i = (b as u16 ^ (crc >> 8)) as u8 as usize;
        crc = (tab[i] ^ (crc << 8)) & 0x3fff;
    }
    crc
}

// NOTE: This is CRC_16_IBM_3740
fn crc16(w: &[u8]) -> u16 {
    let tab = crc_table();

    let mut crc: u16 = 0xffff;
    for b in w {
        let i = (*b as u16 ^ (crc >> 8)) as u8 as usize;
        crc = tab[i] ^ (crc << 8);
    }
    crc
}

const INDEX26: u16 = 0x141d;
// 0x14, 0x1d, // index 26

fn crc_test(cdata: &[u8; 64], cs: u16) {
    for idx in 0..=0xffff {
        let a = idx as u8;
        let b = (idx >> 8) as u8;
        let mut dd = cdata.clone().to_vec();
        dd.extend_from_slice(&[a, b]);
        let s = CCITT.checksum(&dd);
        if s == cs {
            println!("checksum match for idx {idx:04x}");
        }
    }
}

pub fn main() {
    let data0 = [
        0xe8, 0x12, 0x57, 0x0b, 0x2b, 0x10, 0x2f, 0x10, //
        0x30, 0x10, 0x31, 0x10, 0x72, 0x06, 0x5c, 0x15, //
        0x32, 0x10, 0x82, 0x05, 0xff, 0xff, 0x37, 0x10, //
        0xf3, 0x04, 0x81, 0x05, 0xff, 0xff, 0x39, 0x10, //
        0x83, 0x05, 0xf5, 0x04, 0x8a, 0x0c, 0x03, 0x13, //
        0x97, 0x0c, 0x3a, 0x10, 0x3e, 0x10, 0x99, 0x0c, //
        0x01, 0x15, 0x9d, 0x0c, 0x3d, 0x0b, 0xad, 0x15, //
        0xb4, 0x15, 0x40, 0x0b, 0x71, 0x10, 0x45, 0x0b, //
    ];
    /*
    let cs0 = 0x7e4b;
    crc_test(&data0, cs0);
    let data1 = [
        0x5a, 0x10, 0x38, 0x00, 0x5c, 0x10, 0x38, 0x00, //
        0x5e, 0x10, 0x38, 0x00, 0x60, 0x10, 0x38, 0x00, //
        0x62, 0x10, 0x38, 0x00, 0x64, 0x10, 0x38, 0x00, //
        0x66, 0x10, 0x38, 0x00, 0x68, 0x10, 0x38, 0x00, //
        0x6a, 0x10, 0x38, 0x00, 0x6c, 0x10, 0x38, 0x00, //
        0x6e, 0x10, 0x38, 0x00, 0x70, 0x10, 0x38, 0x00, //
        0x72, 0x10, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, //
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    ];
    let cs1 = 0xb1ab;
    crc_test(&data1, cs1);
    */

    let data2 = [
        0x01, 0x62, 0x4f, 0x72, 0x01, 0x00, 0x00, 0x00, //
        0x80, 0x8b, 0x05, 0x00, 0x00, 0x02, 0x00, 0x00, //
        0x00, 0x00, 0xfd, 0x0e, 0xf8, 0x0e, 0x12, 0x15, //
        0x78, 0x0a, 0x00, 0x02, 0x00, 0x00, 0xce, 0x14, //
        0x9d, 0x08, 0xf1, 0x0f, 0xb0, 0x09, 0xa3, 0x08, //
        0xff, 0xff, 0x9b, 0x03, 0x9c, 0x03, 0x9d, 0x03, //
        0x88, 0x0c, 0xff, 0xff, 0xa2, 0x03, 0xfe, 0x06, //
        0xa4, 0x03, 0x3f, 0x0b, 0xa7, 0x08, 0x47, 0x10, //
    ];
    let cs2 = 0xad5c;
    crc_test(&data2, cs2);

    let v = 0x1234;
    let cs = crc_idx(v);
    assert_eq!(cs, 0x38bd);

    let cnum = 0x0000;
    let cs = crc_idx(cnum);
    println!("cs 0000: {cs:04x}");
    let ax_idx22 = 0x01c7;
    let i_chunk = cs ^ ax_idx22;

    println!("i chunk {i_chunk}, idx {ax_idx22}");
    let i0 = i_chunk as u8;
    let i1 = (i_chunk >> 8) as u8;
    let mut dd = data2.clone().to_vec();
    dd.extend_from_slice(&[i0, i1]);
    let ci = CCITT.checksum(&dd);
    // 0xad5c
    println!("{ci:04x}");

    let mut dd = data0.clone().to_vec();
    dd.extend_from_slice(&[0x1d, 0x14]);
    let ci = CCITT.checksum(&dd);
    println!("{ci:04x}");
}
